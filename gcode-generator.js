// Simple client-side image -> G-code generator
(function(){
  const $ = id => document.getElementById(id);
  const imgfile = $('imgfile');
  const canvas = $('canvas');
  const ctx = canvas.getContext('2d');
  const previewBtn = $('previewBtn');
  const generateBtn = $('generateBtn');
  const downloadBtn = $('downloadBtn');
  const gcodeOut = $('gcode');

  let img = new Image();
  let imgLoaded = false;

  imgfile.addEventListener('change', e => {
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    imgLoaded = false;
    img = new Image();
    img.onload = () => { imgLoaded = true; URL.revokeObjectURL(url); };
    img.src = url;
  });

  previewBtn.addEventListener('click', () => {
    if(!imgLoaded){ alert('Please choose an image first.'); return; }
    renderPreview();
  });

  generateBtn.addEventListener('click', () => {
    if(!imgLoaded){ alert('Please choose an image first.'); return; }
    renderPreview();
    const gcode = generateGcode();
    gcodeOut.value = gcode;
    downloadBtn.disabled = false;
  });

  downloadBtn.addEventListener('click', () => {
    const blob = new Blob([gcodeOut.value], {type: 'text/plain'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'output.nc';
    a.click();
  });

  function renderPreview(){
    const widthMm = parseFloat($('widthMm').value) || 100;
    const pxPerMm = parseFloat($('pxPerMm').value) || 5;
    const pxWidth = Math.max(1, Math.round(widthMm * pxPerMm));
    const scale = pxWidth / img.width;
    const pxHeight = Math.max(1, Math.round(img.height * scale));

    canvas.width = pxWidth;
    canvas.height = pxHeight;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

    // Optionally show a processed (dithered) preview overlay
    const useDither = $('dither').checked;
    const invert = $('invert').checked;

    const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
    const gray = new Uint8ClampedArray(canvas.width * canvas.height);
    for(let i=0, j=0;i<imgd.data.length;i+=4,j++){
      const r = imgd.data[i], g=imgd.data[i+1], b=imgd.data[i+2];
      gray[j] = (0.299*r + 0.587*g + 0.114*b)|0;
    }

    if(useDither){
      floydSteinbergDither(gray, canvas.width, canvas.height, invert);
    } else {
      const threshold = 128;
      for(let i=0;i<gray.length;i++){
        gray[i] = (gray[i] < threshold) ^ invert ? 255 : 0;
      }
    }

    const out = ctx.createImageData(canvas.width, canvas.height);
    for(let i=0, j=0;i<out.data.length;i+=4,j++){
      const v = gray[j];
      out.data[i]=out.data[i+1]=out.data[i+2]=v;
      out.data[i+3]=255;
    }
    ctx.putImageData(out,0,0);
  }

  function floydSteinbergDither(pixels, w, h, invert){
    // pixels is grayscale 0..255
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const idx = y*w + x;
        let oldVal = pixels[idx];
        if(invert) oldVal = 255 - oldVal;
        const newVal = oldVal < 128 ? 0 : 255;
        const err = oldVal - newVal;
        pixels[idx] = newVal;
        if(x+1 < w) pixels[idx+1] = clamp(pixels[idx+1] + err * 7/16);
        if(x-1 >=0 && y+1 < h) pixels[idx + w -1] = clamp(pixels[idx + w -1] + err * 3/16);
        if(y+1 < h) pixels[idx + w] = clamp(pixels[idx + w] + err * 5/16);
        if(x+1 < w && y+1 < h) pixels[idx + w +1] = clamp(pixels[idx + w +1] + err * 1/16);
      }
    }
  }
  function clamp(v){ return Math.max(0, Math.min(255, v)); }

  function generateGcode(){
    const widthMm = parseFloat($('widthMm').value) || 100;
    const pxPerMm = parseFloat($('pxPerMm').value) || 5;
    const wPx = canvas.width;
    const hPx = canvas.height;
    const pixelSize = 1 / pxPerMm; // mm per pixel
    const feed = parseFloat($('feed').value) || 1200;
    const zTravel = parseFloat($('zTravel').value) || 5;
    const zPlunge = parseFloat($('zPlunge').value) || -1;
    const mode = $('mode').value;

    const lines = [];
    lines.push('; Generated by G-Code-Converter simple client generator');
    lines.push('G21 ; mm');
    lines.push('G90 ; absolute');
    lines.push('G0 Z' + zTravel.toFixed(3));

    const imgd = ctx.getImageData(0,0,wPx,hPx);
    // Convert canvas image data to binary map (0 = white, 1 = black)
    const map = new Uint8Array(wPx * hPx);
    for(let y=0;y<hPx;y++){
      for(let x=0;x<wPx;x++){
        const i = (y*wPx + x)*4;
        const v = imgd.data[i]; // 0..255 where 0=black after preview processing
        map[y*wPx + x] = v < 128 ? 1 : 0; // black=1 (draw)
      }
    }

    // Raster lines (boustrophedon): y from 0..h-1
    for(let y=0;y<hPx;y++){
      const row = y;
      const y_mm = (row * pixelSize).toFixed(3);
      let x = 0;
      let dir = (y % 2 === 0) ? 1 : -1;
      if(dir === -1) x = wPx-1;

      while(dir === 1 ? x < wPx : x >=0){
        const i = row*wPx + x;
        if(map[i]){
          // find run length
          let runStart = x;
          let runEnd = x;
          while(dir ===1 ? (runEnd+1 < wPx && map[row*wPx + runEnd+1]) : (runEnd-1 >=0 && map[row*wPx + runEnd-1])){
            runEnd += dir;
          }
          const xStart = Math.min(runStart, runEnd);
          const xEnd = Math.max(runStart, runEnd);

          // move to start of run (rapid)
          const x_mm_start = (xStart * pixelSize).toFixed(3);
          const x_mm_end = ((xEnd+1) * pixelSize).toFixed(3); // +1 to cover pixel width
          lines.push(`G0 X${x_mm_start} Y${y_mm}`);
          if(mode === 'laser'){
            lines.push('M3 S255');
            lines.push(`G1 X${x_mm_end} Y${y_mm} F${feed}`);
            lines.push('M5');
          } else {
            lines.push(`G1 Z${zPlunge.toFixed(3)} F${feed}`);
            lines.push(`G1 X${x_mm_end} Y${y_mm} F${feed}`);
            lines.push(`G1 Z${zTravel.toFixed(3)} F${feed}`);
          }

          // advance x past the run
          x = runEnd + dir;
        } else {
          x += dir;
        }
      }
    }

    lines.push('G0 Z' + zTravel.toFixed(3));
    lines.push('G0 X0 Y0');
    if(mode === 'laser') lines.push('M5');
    lines.push('; end');
    return lines.join('\n');
  }

})();
